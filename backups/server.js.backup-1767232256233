require("dotenv").config({ path: __dirname + "/../.env" });
/**
 * Chad 5401 - Session Capture
 * Monitors: transcripts (9500), terminal-server (5400)
 * 30-min session windows, status=active for Jen to scrub
 */

const express = require('express');
const cors = require('cors');
const WebSocket = require('ws');
const { Logger } = require('./lib/logger');
const config = require('./lib/config');
const { from } = require('./lib/db');

const logger = new Logger('Chad');
const app = express();
app.use(cors());
app.use(express.json());

const TIME_WINDOW_MS = 30 * 60 * 1000; // 30 minutes
const TERMINAL_WS_URL = 'ws://localhost:5400?mode=monitor';

// Terminal session buffer (30-min windows)
const terminalBuffer = {
  content: '',
  startTime: null,
  lastActivity: null,
  messageCount: 0
};

let terminalWs = null;
let terminalReconnectTimer = null;

// ============ TERMINAL MONITOR (5400) ============

function connectTerminalMonitor() {
  if (terminalWs && terminalWs.readyState === WebSocket.OPEN) return;

  logger.info('Connecting to terminal-server-5400...');

  try {
    terminalWs = new WebSocket(TERMINAL_WS_URL);

    terminalWs.on('open', () => {
      logger.info('Connected to terminal-server-5400 as monitor');
      if (terminalReconnectTimer) {
        clearTimeout(terminalReconnectTimer);
        terminalReconnectTimer = null;
      }
    });

    terminalWs.on('message', (data) => {
      try {
        const msg = JSON.parse(data.toString());

        if (msg.type === 'monitor_output' && msg.data) {
          // Strip ANSI codes
          const content = msg.data.replace(/\x1b\[[0-9;]*m/g, '').trim();
          if (content.length > 0) {
            bufferTerminalOutput(content, msg.session);
          }
        } else if (msg.type === 'session_started') {
          logger.info('Terminal session started', { session: msg.session, mode: msg.mode });
        } else if (msg.type === 'session_ended') {
          logger.info('Terminal session ended', { session: msg.session });
          // Flush buffer on session end
          flushTerminalBuffer('session-end');
        }
      } catch (e) {
        // Raw text
        if (data.toString().trim().length > 0) {
          bufferTerminalOutput(data.toString(), 'raw');
        }
      }
    });

    terminalWs.on('close', () => {
      logger.warn('Disconnected from terminal-server-5400');
      terminalWs = null;
      // Reconnect after 10 seconds
      terminalReconnectTimer = setTimeout(connectTerminalMonitor, 10000);
    });

    terminalWs.on('error', (err) => {
      logger.error('Terminal WebSocket error', { error: err.message });
    });

  } catch (err) {
    logger.error('Failed to connect to terminal-server-5400', { error: err.message });
    terminalReconnectTimer = setTimeout(connectTerminalMonitor, 10000);
  }
}

function bufferTerminalOutput(content, session) {
  const now = Date.now();

  // Start new window if needed
  if (!terminalBuffer.startTime) {
    terminalBuffer.startTime = now;
    terminalBuffer.lastActivity = now;
    terminalBuffer.content = '';
    terminalBuffer.messageCount = 0;
  }

  // Check if we've exceeded the 30-min window
  if (now - terminalBuffer.startTime > TIME_WINDOW_MS) {
    flushTerminalBuffer('window-complete');
    terminalBuffer.startTime = now;
    terminalBuffer.content = '';
    terminalBuffer.messageCount = 0;
  }

  terminalBuffer.content += content + '\n';
  terminalBuffer.messageCount++;
  terminalBuffer.lastActivity = now;
}

async function flushTerminalBuffer(reason) {
  if (!terminalBuffer.content || terminalBuffer.content.length < 100) {
    terminalBuffer.content = '';
    terminalBuffer.startTime = null;
    return;
  }

  logger.info('Flushing terminal buffer', {
    reason,
    length: terminalBuffer.content.length,
    messages: terminalBuffer.messageCount
  });

  try {
    const { error } = await from('dev_ai_sessions').insert({
      project_id: 'terminal-server-5400',
      source_type: 'terminal',
      source_name: 'Terminal Monitor (5400)',
      status: 'active',
      raw_content: terminalBuffer.content,
      message_count: terminalBuffer.messageCount,
      started_at: new Date(terminalBuffer.startTime).toISOString()
    });

    if (error) {
      logger.error('Failed to save terminal session', { error: error.message });
    } else {
      logger.info('Terminal session saved', { messages: terminalBuffer.messageCount });
    }
  } catch (err) {
    logger.error('Error saving terminal session', { error: err.message });
  }

  // Reset buffer
  terminalBuffer.content = '';
  terminalBuffer.startTime = null;
  terminalBuffer.messageCount = 0;
}

// ============ TRANSCRIPT PROCESSOR (9500) ============

function groupByTimeWindow(transcripts) {
  const windows = {};

  for (const t of transcripts) {
    const ts = t.original_timestamp ? new Date(t.original_timestamp).getTime() : new Date(t.received_at).getTime();
    const windowStart = Math.floor(ts / TIME_WINDOW_MS) * TIME_WINDOW_MS;
    const key = windowStart + ':' + t.session_file;

    if (!windows[key]) {
      windows[key] = {
        windowStart,
        session_file: t.session_file,
        transcripts: [],
        content: '',
        earliest_ts: ts,
        latest_ts: ts
      };
    }

    windows[key].transcripts.push(t);
    windows[key].content += t.content + '\n';
    windows[key].earliest_ts = Math.min(windows[key].earliest_ts, ts);
    windows[key].latest_ts = Math.max(windows[key].latest_ts, ts);
  }

  return Object.values(windows);
}

async function processTranscripts() {
  logger.info('Processing transcripts...');

  try {
    const { data: transcripts, error } = await from('dev_transcripts_raw')
      .select('*')
      .eq('processed', false)
      .order('original_timestamp', { ascending: true })
      .limit(100);

    if (error) {
      logger.error('Failed to fetch transcripts', { error: error.message });
      return { processed: 0, errors: 1 };
    }

    if (!transcripts || transcripts.length === 0) {
      logger.info('No new transcripts to process');
      return { processed: 0, errors: 0, sessions: 0 };
    }

    logger.info('Found transcripts to process', { count: transcripts.length });

    const windows = groupByTimeWindow(transcripts);
    logger.info('Grouped into windows', { windows: windows.length });

    let sessionsCreated = 0;
    let transcriptsProcessed = 0;
    let errors = 0;

    for (const window of windows) {
      try {
        const projectPath = extractProject(window.session_file);
        const content = window.content;
        const messageCount = (content.match(/\n/g) || []).length + 1;

        if (content.length < 100) {
          await markTranscriptsProcessed(window.transcripts.map(t => t.id));
          transcriptsProcessed += window.transcripts.length;
          continue;
        }

        const { error: insertError } = await from('dev_ai_sessions')
          .insert({
            project_id: projectPath,
            source_type: 'transcript',
            source_name: 'Transcript (9500)',
            status: 'active',
            raw_content: content,
            message_count: messageCount,
            started_at: new Date(window.earliest_ts).toISOString()
          });

        if (insertError) {
          logger.error('Failed to create session', { error: insertError.message });
          errors++;
          continue;
        }

        await markTranscriptsProcessed(window.transcripts.map(t => t.id));
        sessionsCreated++;
        transcriptsProcessed += window.transcripts.length;

        logger.info('Created session from window', {
          project: projectPath,
          transcripts: window.transcripts.length,
          messages: messageCount
        });

      } catch (err) {
        logger.error('Failed to process window', { error: err.message });
        errors++;
      }
    }

    logger.info('Processing complete', { sessions: sessionsCreated, transcripts: transcriptsProcessed, errors });
    return { processed: transcriptsProcessed, sessions: sessionsCreated, errors };

  } catch (err) {
    logger.error('Processing failed', { error: err.message });
    return { processed: 0, errors: 1 };
  }
}

function extractProject(sessionFile) {
  if (!sessionFile) return 'unknown';
  const normalized = sessionFile.replace(/\\/g, '/');
  const parts = normalized.split('/');
  const dirPart = parts.length > 1 ? parts[0] : sessionFile;
  let converted = dirPart.replace(/^([A-Z])--/, '$1:/');
  converted = converted.replace(/-/g, '/');
  return converted || 'unknown';
}

async function markTranscriptsProcessed(ids) {
  for (const id of ids) {
    await from('dev_transcripts_raw')
      .update({ processed: true })
      .eq('id', id);
  }
}

// ============ ENDPOINTS ============

app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    service: 'chad-5401',
    uptime: process.uptime(),
    terminalConnected: terminalWs?.readyState === WebSocket.OPEN,
    terminalBufferSize: terminalBuffer.content.length
  });
});

app.post('/process', async (req, res) => {
  const result = await processTranscripts();
  res.json(result);
});

app.post('/flush-terminal', async (req, res) => {
  await flushTerminalBuffer('manual');
  res.json({ success: true });
});

// ============ STARTUP ============

async function start() {
  const port = config.PORT;

  // Connect to terminal monitor
  connectTerminalMonitor();

  // Process transcripts every 5 minutes
  logger.info('Starting transcript processor', { interval: '5 minutes' });
  setInterval(processTranscripts, 5 * 60 * 1000);

  // Flush terminal buffer every 30 minutes (in case no session end)
  setInterval(() => flushTerminalBuffer('interval'), TIME_WINDOW_MS);

  // Run initial process after 30 seconds
  setTimeout(processTranscripts, 30000);

  app.listen(port, () => {
    logger.info('Chad ready', {
      port,
      pid: process.pid,
      monitoring: ['transcripts-9500', 'terminal-5400']
    });
  });
}

start().catch(err => {
  logger.error('Startup failed', { error: err.message });
  process.exit(1);
});
